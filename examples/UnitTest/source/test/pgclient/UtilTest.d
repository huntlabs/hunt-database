/*
 * Copyright (C) 2017 Julien Viet
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */
module test.pgclient.UtilTest;

import hunt.database.base.Util;


import hunt.Assert;
import hunt.Exceptions;
import hunt.logging;
import hunt.net.buffer;
import hunt.util.Common;
import hunt.util.UnitTest;



class UtilTest {

    @Test
    void testReadCString() {
        enum byte[] data = cast(byte[])[
            0x52, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 
            0x53, 0x00, 0x00, 0x00, 0x25, 0x61, 0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 
            0x5F, 0x6E, 0x61, 0x6D, 0x65, 0x00, 0x76, 0x65, 0x72, 0x74, 0x78, 0x2D, 0x70, 0x67, 0x2D, 0x63, 
            0x6C, 0x69, 0x65, 0x6E, 0x74, 0x00, 0x53, 0x00, 0x00, 0x00, 0x19, 0x63, 0x6C, 0x69, 0x65, 0x6E, 
            0x74, 0x5F, 0x65, 0x6E, 0x63, 0x6F, 0x64, 0x69, 0x6E, 0x67, 0x00, 0x55, 0x54, 0x46, 0x38, 0x00, 
            0x53, 0x00, 0x00, 0x00, 0x17, 0x44, 0x61, 0x74, 0x65, 0x53, 0x74, 0x79, 0x6C, 0x65, 0x00, 0x49, 
            0x53, 0x4F, 0x2C, 0x20, 0x4D, 0x44, 0x59, 0x00, 0x53, 0x00, 0x00, 0x00, 0x19, 0x69, 0x6E, 0x74, 
            0x65, 0x67, 0x65, 0x72, 0x5F, 0x64, 0x61, 0x74, 0x65, 0x74, 0x69, 0x6D, 0x65, 0x73, 0x00, 0x6F, 
            0x6E, 0x00, 0x53, 0x00, 0x00, 0x00, 0x1B, 0x49, 0x6E, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6C, 0x53, 
            0x74, 0x79, 0x6C, 0x65, 0x00, 0x70, 0x6F, 0x73, 0x74, 0x67, 0x72, 0x65, 0x73, 0x00, 0x53, 0x00, 
            0x00, 0x00, 0x14, 0x69, 0x73, 0x5F, 0x73, 0x75, 0x70, 0x65, 0x72, 0x75, 0x73, 0x65, 0x72, 0x00, 
            0x6F, 0x6E, 0x00, 0x53, 0x00, 0x00, 0x00, 0x19, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5F, 0x65, 
            0x6E, 0x63, 0x6F, 0x64, 0x69, 0x6E, 0x67, 0x00, 0x55, 0x54, 0x46, 0x38, 0x00, 0x53, 0x00, 0x00, 
            0x00, 0x19, 0x73, 0x65, 0x72, 0x76, 0x65, 0x72, 0x5F, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6F, 0x6E, 
            0x00, 0x39, 0x2E, 0x35, 0x2E, 0x33, 0x00, 0x53, 0x00, 0x00, 0x00, 0x23, 0x73, 0x65, 0x73, 0x73, 
            0x69, 0x6F, 0x6E, 0x5F, 0x61, 0x75, 0x74, 0x68, 0x6F, 0x72, 0x69, 0x7A, 0x61, 0x74, 0x69, 0x6F, 
            0x6E, 0x00, 0x70, 0x6F, 0x73, 0x74, 0x67, 0x72, 0x65, 0x73, 0x00, 0x53, 0x00, 0x00, 0x00, 0x23, 
            0x73, 0x74, 0x61, 0x6E, 0x64, 0x61, 0x72, 0x64, 0x5F, 0x63, 0x6F, 0x6E, 0x66, 0x6F, 0x72, 0x6D, 
            0x69, 0x6E, 0x67, 0x5F, 0x73, 0x74, 0x72, 0x69, 0x6E, 0x67, 0x73, 0x00, 0x6F, 0x6E, 0x00, 0x53, 
            0x00, 0x00, 0x00, 0x17, 0x54, 0x69, 0x6D, 0x65, 0x5A, 0x6F, 0x6E, 0x65, 0x00, 0x6C, 0x6F, 0x63, 
            0x61, 0x6C, 0x74, 0x69, 0x6D, 0x65, 0x00, 0x4B, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x68, 0xB3, 
            0x5A, 0xF5, 0x66, 0x8A, 0x5A, 0x00, 0x00, 0x00, 0x05, 0x49 ];

        ByteBuf inBuffer = Unpooled.wrappedBuffer(data);

        int writerIndex = cast(int)data.length;
        inBuffer.setIndex(9, cast(int)data.length-1);
        trace(inBuffer.toString());


        do {
            int beginIdx = inBuffer.readerIndex();
            byte id = inBuffer.getByte(beginIdx);
            int length = inBuffer.getInt(beginIdx + 1);
            int endIdx = beginIdx + length + 1;
            inBuffer.setIndex(beginIdx + 5, endIdx);

            tracef("id=%02X", id);
            if(id != 0x53) {
                break;
            }

            string key = Util.readCStringUTF8(inBuffer);
            string value = Util.readCStringUTF8(inBuffer);

            tracef("key=%s, value=%s", key, value);
            
            inBuffer.setIndex(endIdx, writerIndex);
        
        } while(inBuffer.readableBytes() > 5);

    }

    // @Test
    // void testWriteHexString() {
    //     assertWriteHexString("00", (byte) 0);
    //     assertWriteHexString("01", (byte) 1);
    //     assertWriteHexString("0a", (byte) 10);
    //     assertWriteHexString("10", (byte) 16);
    //     assertWriteHexString("ff", (byte) 255);
    //     assertWriteHexString("ff0a0a", (byte) 255, (byte)10, (byte)10);
    //     Buffer buff = Buffer.buffer();
    //     for (int i = 0; i < 512;i++) {
    //         buff.appendByte((byte)('A' + i % 26));
    //     }
    // }

    // private static void assertWriteHexString(String expected, byte... data) {
    //     ByteBuf buff = Unpooled.buffer();
    //     Util.writeHexString(Buffer.buffer().appendBytes(data), buff);
    //     String hex = buff.toString(StandardCharsets.UTF_8);
    //     assertEquals(expected, hex);
    // }

    // @Test
    // void testUTF8StringEndDetector() {
    //     assertSeparator("", -1);
    //     assertSeparator("\"", -1);
    //     assertSeparator("\"\"", 1);
    //     assertSeparator("\"a\"", 2);
    //     assertSeparator("\"â‚¬\"", 4);
    //     assertSeparator("\"\\\"\"", 3);
    // }

    // private void assertSeparator(String s, int expected) {
    //     ByteBuf buf = Unpooled.buffer();
    //     buf.writeCharSequence(s, StandardCharsets.UTF_8);
    //     UTF8StringEndDetector processor = new UTF8StringEndDetector();
    //     int actual = buf.forEachByte(processor);
    //     assertEquals(expected, actual);
    // }

}
